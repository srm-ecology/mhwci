require(terra)
require(ggplot2)
require(tidyterra)
require(stringr)
require(magrittr)
require(duckdb)


#' SQL template to calculate summary of any MHW metric
#' 
#' this function to constructs the sql to calculate a summary of an existing 
#' MHW metric over space (eg. summaries for each lat/lon coordinate), with 
#' optional filtering of ensemble and for a period by year.  This inserts these
#' into a string template to generate SQL that can be executed in an MHW 
#' database connection, using duckdb SQL dialect.   
#' The column that contains the summarized metric will be named with the
#' pattern {sql_function}_{mhw_metric}  ( example avg_int_max)
#' 
#' @param mhw_table name of the table to use
#' @param mhw_metric character name of metric ( column ) in the table to summarize: mhw_dur, int_mean, etc
#' @param sqlfun = avg; character aggregate function for duckdb, for example avg, count or median, 
#'        see https://duckdb.org/docs/sql/functions/aggregates, 
#' @param start_year = 2040; integer year to start, inclusive (dates will include this start year), for example 2040
#' @param end_year = 2049 integer year to end, inclusive (dates will include up to 12/31 of the end year), for example 2049
#' @param ensemble_list_string = NA; optional character string.  If NA, then it's ignored and all ensembles are included. 
#'     if it's string that  is a list of ensembles to include in format "006,007,008"  only those with matching 
#'     ensemble will be included.  
#'     ensembles have leading zeros, are 3 digits and this must be a separated list with leading zeros
#' @param group_id_value=NULL optional value to set as an arbitrary  'group' value for all of the rows for these results 
#'        this is useful if these results will be combined with other results and need to be identified. 
#'        for example the gorup=2040 for the decade.  The default is NULL then it's ignored and not group column is NULL.
#'        Note that this is not used for grouping in this step, this step only produces on group  
#' @returns character SQL code to run on an MHW database
#' @export
mhw_metric_summary_sql <- function(mhw_table, 
                                 mhw_metric = 'int_mean', 
                                 sql_function = 'avg', 
                                 start_year=2040, 
                                 end_year=2069,
                                 ensemble_list_string = NA,
                                 group_id_value = NULL) {
  
  # if the ensemble list was sent, create the fragment of SQL that will filter on that list
  #
  if (!is.na(ensemble_list_string)) {
    ensemble_filter <- paste0(" and contains('", ensemble_list_string, "', ensemble) ")
  } else {
    ensemble_filter <- ""
  }
  
  if(is.null(group_id_value) || is.na(group_id_value)) { 
    sql_template <- "SELECT 
       lon, lat,
       {sql_function}({mhw_metric}) as {sql_function}_{mhw_metric}, 
      FROM 
       {mhw_table} 
      WHERE 
        (mhw_onset/10000) >= {start_year} and ((mhw_onset - mod(mhw_onset,10000))/10000) <= {end_year} 
        {ensemble_filter}
      GROUP BY 
        lon, lat
      ORDER by 
        lon, lat
      "
  } else {

  sql_template <- "SELECT 
     lon, lat, 
     {group_id_value} as group_id, 
     {sql_function}({mhw_metric}) as {sql_function}_{mhw_metric}, 
    FROM 
     {mhw_table} 
    WHERE 
      (mhw_onset/10000) >= {start_year} and ((mhw_onset - mod(mhw_onset,10000))/10000) <= {end_year} 
      {ensemble_filter}
    GROUP BY 
      lon, lat, group_id
    ORDER by 
      lon, lat;
    "
  }
  sql <- glue::glue(sql_template)
  
  return(sql)
}


#' create raster of global marine heatwave summary metric per location
#' 
#' using SQL, for example generated by mhw_metric_summary_sql, creates a single
#' raster version with lat, long and metric
#' The raster will have attributes lat, lon and the name of the metric sent
#' @param mhwdb_conn database connection
#' @param mhw_sql character string of SQL that calculates summary.  
#'        SQL must output table with 3 colums (lat, lon, some_column)
#'
#' @param rotate_globe = TRUE boolean True mean rotate the global output so prime
#'    meridian is centered, False, no rotation applied, this works if 
#'    data is maped from 0 to 360 instead of -180 to 180
#' @param crs = 'EPSG:4087' optional character coordinate reference system
#' @return single terra raster, if  
#' @export
summary_metrics_raster <- function(mhwdb_conn, 
                                   mhw_sql,
                                   rotate_globe = TRUE,
                                   crs='EPSG:4087'){
  # mhw_value_name,?
  
  summary_by_loc<- DBI::dbGetQuery(conn=mhwdb_conn, mhw_sql)
  mhw_raster <-terra::rast(summary_by_loc)
  # climate data is 0 to 360, use rotate to make -180 to 180
  if(rotate_globe){
    mhw_raster <- terra::rotate(mhw_raster)
  }
  return(mhw_raster)
}

#' summarize a metric grouped by decades 2040 2050 2060
#'
#' runs summary and creates raster for a 10 year periods for given list of 
#' starting years. uses the summary_by_decades_raster() function and sends 
#' params to that, using the decade start year as the 'group id' value
#' 
#' @param mhw_table name of the table to use
#' @param mhw_metric character name of metric ( column ) in the table to summarize: mhw_dur, int_mean, etc
#' @param sqlfun = avg; character aggregate function for duckdb, for example avg, count or median, 
#'        see https://duckdb.org/docs/sql/functions/aggregates, 
#' @param decades vector of integers, the start year of each 10 year period, can overlap
#' @param ensemble_list_string = NA; optional character string.  If NA, then it's ignored and all ensembles are included. 
#'     if it's string that  is a list of ensembles to include in format "006,007,008"  only those with matching 
#'     ensemble will be included.  
#'     ensembles have leading zeros, are 3 digits and this must be a separated list with leading zeros
#' @param crs default 'EPSG:4087', character valid coordinate reference system

#' @return list of terra rasters of summary statistics, one per decade in decades vector
#' @export
summary_by_decades_raster <- function(mhwdb_conn, 
                                      mhw_table = "arise10_decade_metrics", 
                                      mhw_metric = 'int_mean', 
                                      sql_function = 'avg', 
                                      decades = c(2040, 2050, 2060),
                                      ensemble_list_string = NA,
                                      crs='EPSG:4087'){

    # function used to apply to each decade
    # note we have to use the terra::rast() on the list of data,
    # which is different from a list of rasters.   
    raster_for_decade<-function(start_of_decade) {
    mhw_sql<- mhw_metric_summary_sql(mhw_table, 
                         mhw_metric = mhw_metric,
                         sql_function = sql_function, 
                         start_year=start_of_decade, 
                         end_year=start_of_decade + 9,
                         ensemble_list_string = ensemble_list_string ,
                                     #group_id_value = start_of_decade
    )
    mhw_summary <- DBI::dbGetQuery(conn=mhwdb_conn, mhw_sql)
    mhw_raster <- terra::rast(mhw_summary,type="xyz", crs=crs)
    return(mhw_raster)
  }
  
  raster_list <- terra::rast(lapply(as.list(decades),raster_for_decade ))
  raster_list <- terra::rotate(raster_list)  
  names(raster_list)<- decades
  return(raster_list)

}




